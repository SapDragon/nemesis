# Мова пакетів Nemesis
Мова пакетів даних Nemesis була створена для опису структури бінарних пакетів даних з мінімальним розголошенням. Вона дозволяє визначати ієрархію пакетів, їх поля та типи даних. Мова має простий і зрозумілий синтаксис, що полегшує опис пакетів.
Вона натхненна мовами опису пакетів даних Telegram і Protobuf.

У чому Nemesis поступається іншим мовам опису пакетів даних:
- Зручність: Nemesis при кодогенерації не завжди використовує всі можливості мови, через можливість зловживання ними при реверс-інжинірингу.
- Сирість: Nemesis є Proof of Concept, і не має всіх можливостей інших мов опису пакетів даних.

# Специфікація
Специфікація пакета даних складається з декількох розділів:
- Загальні відомості
- Синтаксис
- Опис пакета в бінарному вигляді
- Можливості для ускладнення реверс-інжинірингу

## Загальні відомості
- Файли специфікації мають розширення `.ns`
- Файли специфікації пакетів даних повинні бути в кодуванні UTF-8

## Синтаксис
Пакет визначається за допомогою ключового слова `package`, за яким слідує ім'я пакета і блок, укладений у фігурні дужки `{}`:
```
package <name> {
    ...
}
```
Всередині блоку пакета можуть бути визначені поля. Кожне поле має ім'я і тип даних, розділені двокрапкою `:`:
```
package <name> {
    <field_name>: <type>;
}
```

Типи даних можуть бути примітивними або складеними. Примітивні типи даних:
- `u8` - 8-бітне беззнакове ціле
- `u16` - 16-бітне беззнакове ціле
- `u32` - 32-бітне беззнакове ціле
- `u64` - 64-бітне беззнакове ціле
- `i8` - 8-бітне знакове ціле
- `i16` - 16-бітне знакове ціле
- `i32` - 32-бітне знакове ціле
- `i64` - 64-бітне знакове ціле
- `f32` - 32-бітне число з плаваючою крапкою
- `f64` - 64-бітне число з плаваючою крапкою
- `bool` - логічне значення
- `string` - рядок (Насправді є своєю структурою, яка містить довжину рядка і зріз u8)

Складені типи даних:
- `[]<type>` - зріз (масив змінної довжини) елементів типу `<type>`
- `[<size>]<type>` - масив фіксованої довжини з `<size>` елементів типу `<type>`

Nemesis підтримує константні дженеріки, які визначаються під час компіляції. Дженеріки дозволяють створювати параметризовані пакети, де типи даних полів можуть бути вказані при використанні пакета.
Для визначення дженеріка використовуються кутові дужки < > після імені пакета, всередині яких вказуються імена типів-параметрів:
```
package name<T1, T2> {
    field1: T1;
    field2: T2;
}
```

При використанні параметризованого пакета необхідно вказати конкретні типи даних для типів-параметрів:
```
package some_package {
    field1: name<u8, u16>;
}
```


У цьому прикладі `field1` є конкретизацією пакета `name`, де `T1` замінений на `u8`, а `T2` на `u16`.

Дженерики в Nemesis є константними і визначаються під час компіляції. Це означає, що всі типи-параметри повинні бути відомі на етапі компіляції і не можуть бути змінені під час виконання. (що і логічно, оскільки Nemesis є мовою опису пакетів даних, а не мовою програмування)

Пакети можуть успадковувати інші пакети за допомогою `:`:
```
package <name> : <parent> {
    ...
}
```

Мова підтримує коментарі в стилі C++:
```
// Однорядковий коментар
/* Багаторядковий
коментар */
```

## Опис пакета в бінарному вигляді
Бінарний пакет складається з наступних частин:
- Заголовок: 4 байти. Контрольна сума імені пакета, обчислена за допомогою алгоритму CRC32. Використовується для ідентифікації пакета.
- Вміст пакета: Бінарне представлення полів пакета відповідно до їх типів даних і порядку оголошення.

Поля пакета слідують одне за одним в тому порядку, в якому вони оголошені в описі пакета. Вкладені пакети також включаються в зміст батьківського пакета.

## Можливості для ускладнення реверс-інжинірингу
Для ускладнення реверс-інжинірингу кодогенератор не генерує зайвої інформації про пакет. Натомість він генерує мінімальний набір методів для читання і запису пакета, а також методи для доступу до полів пакета.
Для більшого захисту ви можете додати обфускацію або віртуалізацію методів доступу до полів пакета.
