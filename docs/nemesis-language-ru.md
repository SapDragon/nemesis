# Nemesis packet language
Язык пакетов данных Nemesis был создан для описания структуры бинарных пакетов данных с минимальным разглашением. Он позволяет определять иерархию пакетов, их поля и типы данных. Язык имеет простой и понятный синтаксис, облегчающий описание пакетов.
Он вдохновлен языками описания пакетов данных Telegram и Protobuf.

В чём Nemesis уступает другим языкам описания пакетов данных:
- Удобство: Nemesis при кодогенерации не всегда использует все возможности языка, из-за возможности злоупотребления ими при реверс-инжиниринге.
- Сырость: Nemesis является Proof of Concept, и не имеет всех возможностей других языков описания пакетов данных.

# Спецификация
Спецификация пакета данных состоит из нескольких разделов:
- Общие сведения
- Синтаксис
- Описание пакета в бинарном виде
- Возможности для усложения реверс-инжиниринга

## Общие сведения
- Файлы спецификации имеют расширение `.ns`
- Файлы спецификации пакетов данных должны быть в кодировке UTF-8

## Синтаксис
Пакет определяется с помощью ключевого слова `package`, за которым следует имя пакета и блок, заключенный в фигурные скобки `{}`:
```
package <name> {
    ...
}
```

Внутри блока пакета могут быть определены поля. Каждое поле имеет имя и тип данных, разделенные двоеточием `:` :
```
package <name> {
    <field_name>: <type>;
}
```

Типы данных могут быть примитивными или составными. Примитивные типы данных:
- `u8`, `u16`, `u32`, `u64` - беззнаковые целые
- `i8`, `i16`, `i32`, `i64` - знаковые целые
- `f32`, `f64` - числа с плавающей точкой
- `bool` - логическое значение
- `string` - строка

Составные типы данных:
- `[]<type>` - слайс (массив переменной длины) элементов типа `<type>`
- `[<size>]<type>` - массив фиксированной длины из `<size>` элементов типа `<type>`

Nemesis поддерживает константные дженерики, которые определяются во время компиляции. Дженерики позволяют создавать параметризованные пакеты, где типы данных полей могут быть указаны при использовании пакета.
Для определения дженерика используются угловые скобки < > после имени пакета, внутри которых указываются имена типов-параметров:
```
package name<T1, T2> {
    field1: T1;
    field2: T2;
}
```

При использовании параметризованного пакета необходимо указать конкретные типы данных для типов-параметров:
```
package some_package {
    field1: name<u8, u16>;
}
```

В этом примере `field1` вляется конкретизацией пакета `name`, где `T1` заменен на `u8`, а `T2` на `u16`.

Дженерики в Nemesis являются константными и определяются во время компиляции. Это означает, что все типы-параметры должны быть известны на этапе компиляции и не могут быть изменены во время выполнения. ( что и логично, так как Nemesis является языком описания пакетов данных, а не языком программирования )

Пакеты могут наследовать другие пакеты с помощью `:'' :
```
package <name> : <parent> {
    ...
}
```


Псевдонимы типов определяются с помощью ключевого слова `type`:
```
type <alias_name> = <existing_type>
```

Поля могут иметь значения по умолчанию:
```
packet <name> {
    <field_name>: <type> = <default_value>;
}
```

Язык поддерживает комментарии в стиле C++:
```
// Однострочный комментарий
/* Многострочный
комментарий */
```

Импорт других файлов Nemesis осуществляется с помощью ключевого слова `import`:
```
import "<file_path>"
```


## Описание пакета в бинарном виде
Бинарный пакет состоит из следующих частей:
- Заголовок: 4 байта. Контрольная сумма имени пакета, вычисленная с помощью алгоритма CRC32. Используется для идентификации пакета.
- Содержимое пакета: Бинарное представление полей пакета в соответствии с их типами данных и порядком объявления.

Поля пакета следуют друг за другом в том порядке, в котором они объявлены в описании пакета. Вложенные пакеты также включаются в содержимое родительского пакета.

## Возможности для усложения реверс-инжиниринга
Для усложнения реверс-инжиниринга кодогенератор не генерирует лишней информации о пакете. Вместо этого он генерирует минимальный набор методов для чтения и записи пакета, а также методы для доступа к полям пакета. 
Для большей защиты вы можете добавить обфускацию, или виртуализацию методов доступа к полям пакета.